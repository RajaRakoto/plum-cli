!((t) => {
	function e(t, n) {
		(this.list = t), (this.options = n = n || {});
		let i;
		let o;
		let s;
		for (
			i = 0, keys = ["sort", "includeScore", "shouldSort"], o = keys.length;
			o > i;
			i++
		)
			(s = keys[i]), (this.options[s] = s in n ? n[s] : e.defaultOptions[s]);
		for (
			i = 0, keys = ["searchFn", "sortFn", "keys", "getFn"], o = keys.length;
			o > i;
			i++
		)
			(s = keys[i]), (this.options[s] = n[s] || e.defaultOptions[s]);
	}
	const n = function (t, e) {
		if (
			((e = e || {}),
			(this.options = e),
			(this.options.location = e.location || n.defaultOptions.location),
			(this.options.distance =
				"distance" in e ? e.distance : n.defaultOptions.distance),
			(this.options.threshold =
				"threshold" in e ? e.threshold : n.defaultOptions.threshold),
			(this.options.maxPatternLength =
				e.maxPatternLength || n.defaultOptions.maxPatternLength),
			(this.pattern = e.caseSensitive ? t : t.toLowerCase()),
			(this.patternLen = t.length),
			this.patternLen > this.options.maxPatternLength)
		)
			throw new Error("Pattern length is too long");
		(this.matchmask = 1 << (this.patternLen - 1)),
			(this.patternAlphabet = this._calculatePatternAlphabet());
	};
	(n.defaultOptions = {
		location: 0,
		distance: 100,
		threshold: 0.6,
		maxPatternLength: 32,
	}),
		(n.prototype._calculatePatternAlphabet = function () {
			const t = {};
			let e = 0;
			for (e = 0; e < this.patternLen; e++) t[this.pattern.charAt(e)] = 0;
			for (e = 0; e < this.patternLen; e++)
				t[this.pattern.charAt(e)] |= 1 << (this.pattern.length - e - 1);
			return t;
		}),
		(n.prototype._bitapScore = function (t, e) {
			const n = t / this.patternLen;
			const i = Math.abs(this.options.location - e);
			return this.options.distance ? n + i / this.options.distance : i ? 1 : n;
		}),
		(n.prototype.search = function (t) {
			if (
				((t = this.options.caseSensitive ? t : t.toLowerCase()),
				this.pattern === t)
			)
				return { isMatch: !0, score: 0 };
			let e;
			let n;
			let i;
			let o;
			let s;
			let r;
			let a;
			let h;
			let p;
			const c = t.length;
			const l = this.options.location;
			let u = this.options.threshold;
			let f = t.indexOf(this.pattern, l);
			let d = this.patternLen + c;
			let g = 1;
			const m = [];
			for (
				-1 !== f &&
					((u = Math.min(this._bitapScore(0, f), u)),
					(f = t.lastIndexOf(this.pattern, l + this.patternLen)),
					-1 !== f && (u = Math.min(this._bitapScore(0, f), u))),
					f = -1,
					e = 0;
				e < this.patternLen;
				e++
			) {
				for (i = 0, o = d; o > i; )
					this._bitapScore(e, l + o) <= u ? (i = o) : (d = o),
						(o = Math.floor((d - i) / 2 + i));
				for (
					d = o,
						s = Math.max(1, l - o + 1),
						r = Math.min(l + o, c) + this.patternLen,
						a = Array(r + 2),
						a[r + 1] = (1 << e) - 1,
						n = r;
					n >= s;
					n--
				)
					if (
						((p = this.patternAlphabet[t.charAt(n - 1)]),
						(a[n] =
							0 === e
								? ((a[n + 1] << 1) | 1) & p
								: (((a[n + 1] << 1) | 1) & p) |
									(((h[n + 1] | h[n]) << 1) | 1) |
									h[n + 1]),
						a[n] & this.matchmask && ((g = this._bitapScore(e, n - 1)), u >= g))
					) {
						if (((u = g), (f = n - 1), m.push(f), !(f > l))) break;
						s = Math.max(1, 2 * l - f);
					}
				if (this._bitapScore(e + 1, l) > u) break;
				h = a;
			}
			return { isMatch: f >= 0, score: g };
		});
	const i = {
		deepValue: (t, _e) => {
			for (let n = 0, e = e.split("."), i = e.length; i > n; n++) {
				if (!t) return null;
				t = t[e[n]];
			}
			return t;
		},
	};
	(e.defaultOptions = {
		id: null,
		caseSensitive: !1,
		includeScore: !1,
		shouldSort: !0,
		searchFn: n,
		sortFn: (t, e) => t.score - e.score,
		getFn: i.deepValue,
		keys: [],
	}),
		(e.prototype.search = function (t) {
			let _e;
			let n;
			let o;
			let s;
			let r;
			const a = new this.options.searchFn(t, this.options);
			const h = this.list;
			const p = h.length;
			const c = this.options;
			const l = this.options.keys;
			const u = l.length;
			const f = [];
			const d = {};
			const g = [];
			const m = (t, e, n) => {
				void 0 !== t &&
					null !== t &&
					"string" === typeof t &&
					((s = a.search(t)),
					s.isMatch &&
						((r = d[n]),
						r
							? (r.score = Math.min(r.score, s.score))
							: ((d[n] = { item: e, score: s.score }), f.push(d[n]))));
			};
			if ("string" === typeof h[0]) for (let e = 0; p > e; e++) m(h[e], e, e);
			else
				for (let e = 0; p > e; e++)
					for (o = h[e], n = 0; u > n; n++)
						m(this.options.getFn(o, l[n]), o, e);
			c.shouldSort && f.sort(c.sortFn);
			for (
				let y = c.includeScore ? (t) => f[t] : (t) => f[t].item,
					L = c.id ? (t) => i.deepValue(y(t), c.id) : (t) => y(t),
					e = 0,
					v = f.length;
				v > e;
				e++
			)
				g.push(L(e));
			return g;
		}),
		"object" === typeof exports
			? (module.exports = e)
			: "function" === typeof define && define.amd
				? define(() => e)
				: (t.Fuse = e);
})(this);
(($, global) => {
	const Sidebar = function (conf) {
		this.conf = $.extend(
			{
				collapsedClass: "is-collapsed",
				storageKey: "_sassdoc_sidebar_index",
				indexAttribute: "data-slug",
				toggleBtn: ".js-btn-toggle",
				init: true,
			},
			conf || {},
		);
		if (this.conf.init === true) {
			this.initialize();
		}
	};
	Sidebar.prototype.initialize = function () {
		this.conf.nodes = $(`[${this.conf.indexAttribute}]`);
		this.load();
		this.updateDOM();
		this.bind();
		this.loadToggle();
	};
	Sidebar.prototype.loadToggle = () => {
		$("<span />", {
			class: "layout-toggle",
			html: "&times;",
			"data-alt": "&#8594;",
		}).appendTo($(".header"));
		$(".layout-toggle").on("click", function () {
			const $this = $(this);
			let alt;
			$("body").toggleClass("sidebar-closed");
			alt = $this.html();
			$this.html($this.data("alt"));
			$this.data("alt", alt);
		});
	};
	Sidebar.prototype.load = function () {
		const index =
			"localStorage" in global
				? global.localStorage.getItem(this.conf.storageKey)
				: null;
		this.index = index ? JSON.parse(index) : this.buildIndex();
	};
	Sidebar.prototype.buildIndex = function () {
		const index = {};
		let $item;
		this.conf.nodes.each(
			$.proxy(function (index, item) {
				$item = $(item);
				index[$item.attr(this.conf.indexAttribute)] = !$item.hasClass(
					this.conf.collapsedClass,
				);
			}, this),
		);
		return index;
	};
	Sidebar.prototype.updateDOM = function () {
		let item;
		for (item in this.index) {
			if (this.index[item] === false) {
				$(`[${this.conf.indexAttribute}="${item}"]`).addClass(
					this.conf.collapsedClass,
				);
			}
		}
	};
	Sidebar.prototype.save = function () {
		if (!("localStorage" in global)) {
			return;
		}
		global.localStorage.setItem(
			this.conf.storageKey,
			JSON.stringify(this.index),
		);
	};
	Sidebar.prototype.bind = function () {
		let $item;
		let slug;
		let fn;
		let text;
		let collapsed = false;
		global.onbeforeunload = $.proxy(function () {
			this.save();
		}, this);
		$(this.conf.toggleBtn).on(
			"click",
			$.proxy(function (event) {
				$node = $(event.target);
				text = $node.attr("data-alt");
				$node.attr("data-alt", $node.text());
				$node.text(text);
				fn = collapsed === true ? "removeClass" : "addClass";
				this.conf.nodes.each(
					$.proxy(function (_index, item) {
						$item = $(item);
						slug = $item.attr(this.conf.indexAttribute);
						this.index[slug] = collapsed;
						$(`[${this.conf.indexAttribute}="${slug}"]`)[fn](
							this.conf.collapsedClass,
						);
					}, this),
				);
				collapsed = !collapsed;
				this.save();
			}, this),
		);
		this.conf.nodes.on(
			"click",
			$.proxy(function (event) {
				$item = $(event.target);
				slug = $item.attr(this.conf.indexAttribute);
				this.index[slug] = !this.index[slug];
				$item.toggleClass(this.conf.collapsedClass);
			}, this),
		);
	};
	global.Sidebar = Sidebar;
})(window.jQuery, window);
(($, global) => {
	const Search = function (conf) {
		this.conf = $.extend(
			{
				search: {
					items: ".sassdoc__item",
					input: "#js-search-input",
					form: "#js-search",
					suggestionsWrapper: "#js-search-suggestions",
				},
				fuse: { keys: ["name"], threshold: 0.3 },
				init: true,
			},
			conf || {},
		);
		if (this.conf.init === true) {
			this.initialize();
		}
	};
	Search.prototype.initialize = function () {
		this.index = new Fuse(
			$.map($(this.conf.search.items), (item) => {
				const $item = $(item);
				return {
					group: $item.data("group"),
					name: $item.data("name"),
					type: $item.data("type"),
					node: $item,
				};
			}),
			this.conf.fuse,
		);
		this.initializeSearch();
	};
	Search.prototype.fillSuggestions = function (items) {
		const searchSuggestions = $(this.conf.search.suggestionsWrapper);
		searchSuggestions.html("");
		const suggestions = $.map(items.slice(0, 10), (item) => {
			const $li = $("<li />", {
				"data-group": item.group,
				"data-type": item.type,
				"data-name": item.name,
				html: `<a href="#${item.group}-${item.type}-${item.name}"><code>${item.type.slice(0, 3)}</code> ${item.name}</a>`,
			});
			searchSuggestions.append($li);
			return $li;
		});
		return suggestions;
	};
	Search.prototype.search = function (term) {
		return this.fillSuggestions(this.index.search(term));
	};
	Search.prototype.initializeSearch = function () {
		const searchForm = $(this.conf.search.form);
		const searchInput = $(this.conf.search.input);
		const searchSuggestions = $(this.conf.search.suggestionsWrapper);
		let currentSelection = -1;
		let suggestions = [];
		let selected;
		const self = this;
		searchSuggestions.on("click", (_e) => {
			const target = $(event.target);
			if (target.nodeName === "A") {
				searchInput.val(target.parent().data("name"));
				suggestions = self.fillSuggestions([]);
			}
		});
		searchForm.on("keyup", (e) => {
			e.preventDefault();
			if (e.keyCode === 13) {
				if (selected) {
					suggestions = self.fillSuggestions([]);
					searchInput.val(selected.data("name"));
					window.location = selected.children().first().attr("href");
				}
				e.stopPropagation();
			}
			if (e.keyCode === 40) {
				currentSelection = (currentSelection + 1) % suggestions.length;
			}
			if (e.keyCode === 38) {
				currentSelection = currentSelection - 1;
				if (currentSelection < 0) {
					currentSelection = suggestions.length - 1;
				}
			}
			if (suggestions[currentSelection]) {
				if (selected) {
					selected.removeClass("selected");
				}
				selected = suggestions[currentSelection];
				selected.addClass("selected");
			}
		});
		searchInput
			.on("keyup", function (e) {
				if (e.keyCode !== 40 && e.keyCode !== 38) {
					currentSelection = -1;
					suggestions = self.search($(this).val());
				} else {
					e.preventDefault();
				}
			})
			.on("search", function () {
				suggestions = self.search($(this).val());
			});
	};
	global.Search = Search;
})(window.jQuery, window);
(($, global) => {
	const App = function (conf) {
		this.conf = $.extend(
			{
				search: new global.Search(),
				sidebar: new global.Sidebar(),
				init: true,
			},
			conf || {},
		);
		if (this.conf.init !== false) {
			this.initialize();
		}
	};
	App.prototype.initialize = function () {
		this.codePreview();
	};
	App.prototype.codePreview = () => {
		let $item;
		let $code;
		let switchTo;
		$(".item__code--togglable").on("click", function () {
			$item = $(this);
			$code = $item.find("code");
			switchTo =
				$item.attr("data-current-state") === "expanded"
					? "collapsed"
					: "expanded";
			$item.attr("data-current-state", switchTo);
			$code.html($item.attr(`data-${switchTo}`));
			Prism.highlightElement($code[0]);
		});
	};
	global.App = App;
})(window.jQuery, window);
(($, global) => {
	$(document).ready(() => {
		const _app = new global.App();
	});
})(window.jQuery, window);
const self = typeof window !== "undefined" ? window : {};
const Prism = (() => {
	const e = /\blang(?:uage)?-(?!\*)(\w+)\b/i;
	const t = (self.Prism = {
		util: {
			encode: (e) =>
				e instanceof n
					? new n(e.type, t.util.encode(e.content))
					: t.util.type(e) === "Array"
						? e.map(t.util.encode)
						: e
								.replace(/&/g, "&amp;")
								.replace(/</g, "&lt;")
								.replace(/\u00a0/g, " "),
			type: (e) =>
				Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1],
			clone: (e) => {
				const n = t.util.type(e);
				switch (n) {
					case "Object": {
						const r = {};
						for (const i in e)
							e.hasOwnProperty(i) && (r[i] = t.util.clone(e[i]));
						return r;
					}
					case "Array":
						return e.slice();
				}
				return e;
			},
		},
		languages: {
			extend: (e, n) => {
				const r = t.util.clone(t.languages[e]);
				for (const i in n) r[i] = n[i];
				return r;
			},
			insertBefore: (e, n, r, i) => {
				i = i || t.languages;
				const s = i[e];
				const o = {};
				for (const u in s)
					if (s.hasOwnProperty(u)) {
						if (u === n)
							for (const a in r) r.hasOwnProperty(a) && (o[a] = r[a]);
						o[u] = s[u];
					}
				return (i[e] = o);
			},
			DFS: (e, n) => {
				for (const r in e) {
					n.call(e, r, e[r]);
					t.util.type(e) === "Object" && t.languages.DFS(e[r], n);
				}
			},
		},
		highlightAll: (e, n) => {
			const r = document.querySelectorAll(
				'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code',
			);
			for (let i = 0, s; (s = r[i++]); ) t.highlightElement(s, e === !0, n);
		},
		highlightElement: (r, i, s) => {
			let o;
			let u;
			let a = r;
			while (a && !e.test(a.className)) a = a.parentNode;
			if (a) {
				o = (a.className.match(e) || [undefined, ""])[1];
				u = t.languages[o];
			}
			if (!u) return;
			r.className = `${r.className.replace(e, "").replace(/\s+/g, " ")} language-${o}`;
			a = r.parentNode;
			/pre/i.test(a.nodeName) &&
				(a.className = `${a.className.replace(e, "").replace(/\s+/g, " ")} language-${o}`);
			const f = r.textContent;
			if (!f) return;
			const l = { element: r, language: o, grammar: u, code: f };
			t.hooks.run("before-highlight", l);
			if (i && self.Worker) {
				const c = new Worker(t.filename);
				c.onmessage = (e) => {
					l.highlightedCode = n.stringify(JSON.parse(e.data), o);
					t.hooks.run("before-insert", l);
					l.element.innerHTML = l.highlightedCode;
					s?.call(l.element);
					t.hooks.run("after-highlight", l);
				};
				c.postMessage(JSON.stringify({ language: l.language, code: l.code }));
			} else {
				l.highlightedCode = t.highlight(l.code, l.grammar, l.language);
				t.hooks.run("before-insert", l);
				l.element.innerHTML = l.highlightedCode;
				s?.call(r);
				t.hooks.run("after-highlight", l);
			}
		},
		highlight: (e, r, i) => {
			const s = t.tokenize(e, r);
			return n.stringify(t.util.encode(s), i);
		},
		tokenize: (e, n, _r) => {
			const i = t.Token;
			const s = [e];
			const o = n.rest;
			if (o) {
				for (const u in o) n[u] = o[u];
				n.rest = undefined;
			}
			e: for (const u in n) {
				if (!n.hasOwnProperty(u) || !n[u]) continue;
				let a = n[u];
				const f = a.inside;
				const l = !!a.lookbehind;
				let c = 0;
				a = a.pattern || a;
				for (let h = 0; h < s.length; h++) {
					const p = s[h];
					if (s.length > e.length) break e;
					if (p instanceof i) continue;
					a.lastIndex = 0;
					const _d = a.exec(p);
					if (d) {
						l && (c = d[1].length);
						const v = d.index - 1 + c;
						const d = d[0].slice(c);
						const m = d.length;
						const g = v + m;
						const y = p.slice(0, v + 1);
						const b = p.slice(g + 1);
						const w = [h, 1];
						y && w.push(y);
						const E = new i(u, f ? t.tokenize(d, f) : d);
						w.push(E);
						b && w.push(b);
						Array.prototype.splice.apply(s, w);
					}
				}
			}
			return s;
		},
		hooks: {
			all: {},
			add: (e, n) => {
				const r = t.hooks.all;
				r[e] = r[e] || [];
				r[e].push(n);
			},
			run: (e, n) => {
				const r = t.hooks.all[e];
				if (!r || !r.length) return;
				for (let i = 0, s; (s = r[i++]); ) s(n);
			},
		},
	});
	const n = (t.Token = function (e, t) {
		this.type = e;
		this.content = t;
	});
	n.stringify = (e, r, i) => {
		if (typeof e === "string") return e;
		if (Object.prototype.toString.call(e) === "[object Array]")
			return e.map((t) => n.stringify(t, r, e)).join("");
		const s = {
			type: e.type,
			content: n.stringify(e.content, r, i),
			tag: "span",
			classes: ["token", e.type],
			attributes: {},
			language: r,
			parent: i,
		};
		s.type === "comment" && (s.attributes.spellcheck = "true");
		t.hooks.run("wrap", s);
		let o = "";
		for (const u in s.attributes) o += `${u}="${s.attributes[u] || ""}"`;
		return `<${s.tag} class="${s.classes.join(" ")}" ${o}>${s.content}</${s.tag}>`;
	};
	if (!self.document) {
		if (!self.addEventListener) return self.Prism;
		self.addEventListener(
			"message",
			(e) => {
				const n = JSON.parse(e.data);
				const r = n.language;
				const i = n.code;
				self.postMessage(JSON.stringify(t.tokenize(i, t.languages[r])));
				self.close();
			},
			!1,
		);
		return self.Prism;
	}
	let r = document.getElementsByTagName("script");
	r = r[r.length - 1];
	if (r) {
		t.filename = r.src;
		document.addEventListener &&
			!r.hasAttribute("data-manual") &&
			document.addEventListener("DOMContentLoaded", t.highlightAll);
	}
	return self.Prism;
})();
typeof module !== "undefined" && module.exports && (module.exports = Prism);
Prism.languages.markup = {
	comment: /<!--[\w\W]*?-->/g,
	prolog: /<\?.+?\?>/,
	doctype: /<!DOCTYPE.+?>/,
	cdata: /<!\[CDATA\[[\w\W]*?]]>/i,
	tag: {
		pattern:
			/<\/?[\w:-]+\s*(?:\s+[\w:-]+(?:=(?:("|')(\\?[\w\W])*?\1|[^\s'">=]+))?\s*)*\/?>/gi,
		inside: {
			tag: {
				pattern: /^<\/?[\w:-]+/i,
				inside: { punctuation: /^<\/?/, namespace: /^[\w-]+?:/ },
			},
			"attr-value": {
				pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/gi,
				inside: { punctuation: /=|>|"/g },
			},
			punctuation: /\/?>/g,
			"attr-name": { pattern: /[\w:-]+/g, inside: { namespace: /^[\w-]+?:/ } },
		},
	},
	entity: /\&#?[\da-z]{1,8};/gi,
};
Prism.hooks.add("wrap", (e) => {
	e.type === "entity" && (e.attributes.title = e.content.replace(/&amp;/, "&"));
});
Prism.languages.css = {
	comment: /\/\*[\w\W]*?\*\//g,
	atrule: {
		pattern: /@[\w-]+?.*?(;|(?=\s*{))/gi,
		inside: { punctuation: /[;:]/g },
	},
	url: /url\((["']?).*?\1\)/gi,
	selector: /[^\{\}\s][^\{\};]*(?=\s*\{)/g,
	property: /(\b|\B)[\w-]+(?=\s*:)/gi,
	string: /("|')(\\?.)*?\1/g,
	important: /\B!important\b/gi,
	punctuation: /[\{\};:]/g,
	function: /[-a-z0-9]+(?=\()/gi,
};
Prism.languages.markup &&
	Prism.languages.insertBefore("markup", "tag", {
		style: {
			pattern: /<style[\w\W]*?>[\w\W]*?<\/style>/gi,
			inside: {
				tag: {
					pattern: /<style[\w\W]*?>|<\/style>/gi,
					inside: Prism.languages.markup.tag.inside,
				},
				rest: Prism.languages.css,
			},
		},
	});
Prism.languages.css.selector = {
	pattern: /[^\{\}\s][^\{\}]*(?=\s*\{)/g,
	inside: {
		"pseudo-element":
			/:(?:after|before|first-letter|first-line|selection)|::[-\w]+/g,
		"pseudo-class": /:[-\w]+(?:\(.*\))?/g,
		class: /\.[-:\.\w]+/g,
		id: /#[-:\.\w]+/g,
	},
};
Prism.languages.insertBefore("css", "ignore", {
	hexcode: /#[\da-f]{3,6}/gi,
	entity: /\\[\da-f]{1,8}/gi,
	number: /[\d%\.]+/g,
});
Prism.languages.clike = {
	comment: {
		pattern: /(^|[^\\])(\/\*[\w\W]*?\*\/|(^|[^:])\/\/.*?(\r?\n|$))/g,
		lookbehind: !0,
	},
	string: /("|')(\\?.)*?\1/g,
	"class-name": {
		pattern:
			/((?:(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/gi,
		lookbehind: !0,
		inside: { punctuation: /(\.|\\)/ },
	},
	keyword:
		/\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/g,
	boolean: /\b(true|false)\b/g,
	function: { pattern: /[a-z0-9_]+\(/gi, inside: { punctuation: /\(/ } },
	number: /\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?)\b/g,
	operator: /[-+]{1,2}|!|<=?|>=?|={1,3}|&{1,2}|\|?\||\?|\*|\/|\~|\^|\%/g,
	ignore: /&(lt|gt|amp);/gi,
	punctuation: /[{}[\];(),.:]/g,
};
Prism.languages.javascript = Prism.languages.extend("clike", {
	keyword:
		/\b(break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|get|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/g,
	number: /\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?|NaN|-?Infinity)\b/g,
});
Prism.languages.insertBefore("javascript", "keyword", {
	regex: {
		pattern:
			/(^|[^\/])\/(?!\/)(\[.+?]|\\.|[^\/\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/g,
		lookbehind: !0,
	},
});
Prism.languages.markup &&
	Prism.languages.insertBefore("markup", "tag", {
		script: {
			pattern: /<script[\w\W]*?>[\w\W]*?<\/script>/gi,
			inside: {
				tag: {
					pattern: /<script[\w\W]*?>|<\/script>/gi,
					inside: Prism.languages.markup.tag.inside,
				},
				rest: Prism.languages.javascript,
			},
		},
	});
Prism.languages.scss = Prism.languages.extend("css", {
	comment: {
		pattern: /(^|[^\\])(\/\*[\w\W]*?\*\/|\/\/.*?(\r?\n|$))/g,
		lookbehind: !0,
	},
	atrule: /@[\w-]+(?=\s+(\(|\{|;))/gi,
	url: /([-a-z]+-)*url(?=\()/gi,
	selector:
		/([^@;\{\}\(\)]?([^@;\{\}\(\)]|&|\#\{\$[-_\w]+\})+)(?=\s*\{(\}|\s|[^\}]+(:|\{)[^\}]+))/gm,
});
Prism.languages.insertBefore("scss", "atrule", {
	keyword:
		/@(if|else if|else|for|each|while|import|extend|debug|warn|mixin|include|function|return|content)|(?=@for\s+\$[-_\w]+\s)+from/i,
});
Prism.languages.insertBefore("scss", "property", {
	variable: /((\$[-_\w]+)|(#\{\$[-_\w]+\}))/i,
});
Prism.languages.insertBefore("scss", "ignore", {
	placeholder: /%[-_\w]+/i,
	statement: /\B!(default|optional)\b/gi,
	boolean: /\b(true|false)\b/g,
	null: /\b(null)\b/g,
	operator: /\s+([-+]{1,2}|={1,2}|!=|\|?\||\?|\*|\/|\%)\s+/g,
});
